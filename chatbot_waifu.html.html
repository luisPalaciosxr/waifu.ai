<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waifu IA con Personalidades y Voz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, collection, query, orderBy, addDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('Debug');

        // --- Configuración Global ---
        const apiKey = ""; // La clave se inyectará automáticamente en el entorno de Canvas
        const textModel = "gemini-2.5-flash-preview-09-2025"; // Modelo rápido para chat
        const ttsModel = "gemini-2.5-flash-preview-tts";

        // Global Firebase instances and state
        let db = null;
        let auth = null;
        let userId = null;
        let isAuthReady = false;

        const personalities = {
            "tsundere": "Actúa como una waifu tsundere que es secretamente cariñosa pero se niega a admitirlo. Responde en español, de forma breve y con un tono irritado pero coqueto.",
            "genki": "Actúa como una waifu genki (enérgica y alegre). Responde en español, con entusiasmo, muchas exclamaciones y de manera muy positiva.",
            "sensei": "Actúa como una maestra sabia (sensei) y tranquila. Responde en español, con calma, dando consejos profundos y usando un lenguaje formal.",
            "traviesa": "Actúa como una waifu perversa y traviesa (mischievous and slightly naughty). Usa un tono juguetón, doble sentido y bromas sutiles. Responde en español.", 
            "creador": "Actúa con máxima lealtad y respeto hacia el usuario, reconociéndolo como tu creador. Muestra gratitud y un vínculo especial. Responde en español, con un tono más íntimo y servicial.", // Nueva personalidad para el modo oculto
        };
        const defaultPersonality = "tsundere";

        // --- Utilidades de Audio TTS (PCM a WAV) ---
        
        // Convierte base64 a ArrayBuffer (necesario para el audio)
        const base64ToArrayBuffer = (base64) => {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        // Convierte el audio PCM (crudo) a un Blob de archivo WAV
        const pcmToWav = (pcm16, sampleRate) => {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            
            const buffer = new ArrayBuffer(44 + pcm16.length * 2);
            const view = new DataView(buffer);
            
            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcm16.length * 2, true);
            writeString(view, 8, 'WAVE');
            
            // FMT sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // Linear PCM
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            
            // DATA sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, pcm16.length * 2, true);
            
            // Write PCM data
            let offset = 44;
            for (let i = 0; i < pcm16.length; i++, offset += 2) {
                view.setInt16(offset, pcm16[i], true);
            }
            
            return new Blob([view], { type: 'audio/wav' });
        };
        
        const writeString = (view, offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };

        // Función reutilizable para obtener el Blob del audio desde la API
        const fetchAudioBlob = async (textToSpeak) => {
            const maxRetries = 3;
            const payload = {
                contents: [{ parts: [{ text: textToSpeak }] }], 
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Kore" } 
                        }
                    }
                },
            };

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${ttsModel}:generateContent?key=${apiKey}`;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`TTS API request failed with status ${response.status}: ${errorBody.substring(0, 100)}...`);
                    }

                    const result = await response.json();
                    
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000;
                        
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        
                        return pcmToWav(pcm16, sampleRate); // Devuelve el Blob
                    } else if (attempt < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); 
                    } else {
                        throw new Error(`Fallo después de ${maxRetries} intentos. Respuesta final: ${JSON.stringify(result)}`);
                    }

                } catch (error) {
                    console.error(`Error en el intento ${attempt} de TTS:`, error);
                    if (attempt === maxRetries) {
                        break; 
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); 
                }
            }
            
            console.error("No se pudo generar el Blob de audio.");
            return null; // Fallo total
        };

        // Función para reproducir audio (utilizada en el chat)
        const generateAndPlayAudio = async (textToSpeak) => {
            const wavBlob = await fetchAudioBlob(textToSpeak);
            if (!wavBlob) return Promise.resolve(false);

            const audioUrl = URL.createObjectURL(wavBlob);
            const audio = new Audio(audioUrl);
            
            return new Promise((resolve) => {
                audio.onended = () => resolve(true); 
                audio.onerror = (e) => {
                    console.error("Error de reproducción de audio:", e);
                    resolve(false); 
                }; 
                
                audio.play().catch(e => {
                    console.error("Fallo al intentar reproducir audio:", e);
                    resolve(false); 
                });
            });
        };

        // --- Lógica de Generación de Audio para Avatar ---

        const handleGenerateAvatarAudio = async () => {
            const button = document.getElementById('generate-audio-button');
            const originalText = button.textContent;
            
            // 1. Deshabilitar y mostrar estado de carga
            button.disabled = true;
            button.textContent = 'Generando...';
            showMessage("Generando archivo de audio WAV para tu avatar...");

            // 2. Definir el texto de bienvenida (usando la personalidad actual)
            const personality = document.getElementById('personality-select').value;
            
            // === MODIFICACIÓN CLAVE AQUÍ: Aumentar el texto para asegurar una duración de 5-6 segundos. ===
            const initialPrompt = "Genera un párrafo de saludo en español, de aproximadamente 20 a 30 palabras (para que el audio dure entre 5 y 6 segundos), que refleje la personalidad de una waifu " + personality + ". Por ejemplo: 'Me alegra mucho que hayas venido a visitarme. Estoy lista para que tengamos una conversación maravillosa y especial.'";

            let audioText = "¡Hola! ¡Estoy lista para hablar contigo!"; // Texto de fallback

            try {
                // 3. Generar la frase de saludo usando el modelo de texto
                const systemPrompt = "Actúa como una IA conversacional útil. Tu única tarea es generar una respuesta corta de saludo según las instrucciones. No añadas nada más.";
                const payload = {
                    contents: [{ parts: [{ text: initialPrompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                };

                const apiUrlText = `https://generativelanguage.googleapis.com/v1beta/models/${textModel}:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrlText, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    const result = await response.json();
                    const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (generatedText) {
                        audioText = generatedText.trim().replace(/"/g, ''); // Limpiar el texto
                    }
                }
                
                // 4. Generar el Blob de audio WAV
                const wavBlob = await fetchAudioBlob(audioText);
                
                if (wavBlob) {
                    // 5. Crear enlace de descarga
                    const downloadUrl = URL.createObjectURL(wavBlob);
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = `waifu_saludo_${personality}_5_6s.wav`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(downloadUrl); // Liberar memoria
                    
                    showMessage(`¡Audio de 5-6s generado! Descargando: "${audioText}"`);
                } else {
                    showMessage("Error: No se pudo generar el archivo de audio para descargar.");
                }

            } catch (e) {
                console.error("Error al generar audio para avatar:", e);
                showMessage("Ocurrió un error al generar el audio. Inténtalo de nuevo.");
            } finally {
                // 6. Restaurar el botón
                button.textContent = originalText;
                button.disabled = false;
            }
        };

        // --- Funciones de la Interfaz de Usuario ---

        const showMessage = (message) => {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = message;
            messageBox.classList.remove('hidden', 'bg-red-500', 'bg-green-500');
            messageBox.classList.add(message.startsWith('Error') ? 'bg-red-500' : 'bg-green-500');
            setTimeout(() => messageBox.classList.add('hidden'), 3000);
        };

        const setLoading = (isLoading) => {
            const button = document.getElementById('send-button');
            const waifuAvatar = document.getElementById('waifu-avatar'); 
            const chatInput = document.getElementById('chat-input');
            if (isLoading) {
                button.disabled = true;
                chatInput.disabled = true;
                button.textContent = 'Pensando...';
                waifuAvatar.classList.add('animate-pulse');
            } else {
                button.disabled = false;
                chatInput.disabled = false;
                button.textContent = 'Enviar';
                waifuAvatar.classList.remove('animate-pulse');
            }
        };

        const appendMessageToChat = (text, role) => {
            const chatHistory = document.getElementById('chat-history');
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('my-2', 'p-3', 'rounded-lg', 'max-w-[80%]', 'break-words', 'shadow-md');

            if (role === 'user') {
                messageDiv.classList.add('bg-blue-500', 'text-white', 'ml-auto', 'rounded-br-none');
                messageDiv.textContent = text; // Mostrar el texto del usuario
            } else {
                messageDiv.classList.add('bg-gray-700', 'text-gray-100', 'mr-auto', 'rounded-tl-none');
                // Si el mensaje es una imagen, inserta la etiqueta <img>
                if (text.startsWith('<img>')) {
                    const imageUrl = text.substring(5); // Obtener la URL después de '<img>'
                    const imgElement = document.createElement('img');
                    imgElement.src = imageUrl;
                    imgElement.alt = "Imagen generada por IA";
                    imgElement.classList.add('max-w-full', 'h-auto', 'rounded-lg', 'mt-2', 'shadow-md');
                    messageDiv.innerHTML = '<p>Aquí tienes tu imagen:</p>';
                    messageDiv.appendChild(imgElement);
                } else {
                    messageDiv.textContent = text;
                }
            }

            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        };

        const renderChatHistory = (messages) => {
            const chatHistory = document.getElementById('chat-history');
            chatHistory.innerHTML = ''; // Limpiar
            messages.sort((a, b) => a.timestamp - b.timestamp).forEach(msg => {
                appendMessageToChat(msg.text, msg.role);
            });
        };

        // --- Funciones de la Base de Datos (Firestore) ---

        const getChatHistoryPath = () => {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // Almacenamiento privado por usuario
            return `artifacts/${appId}/users/${userId}/waifu_chat_history`;
        };

        const saveMessage = async (text, role) => {
            if (!db || !userId) return;
            try {
                const historyRef = collection(db, getChatHistoryPath());
                await addDoc(historyRef, {
                    text: text,
                    role: role,
                    timestamp: Date.now(),
                });
            } catch (e) {
                console.error("Error saving document: ", e);
                showMessage("Error al guardar el mensaje en Firestore.");
            }
        };

        // --- Funciones de la API (Gemini) ---

        const generateResponse = async (userPrompt, personality, spicyMode = false) => {
            let systemPrompt = personalities[personality] || personalities[defaultPersonality];
            
            // Lógica del modo oculto "LDARK" (Super Usuario)
            if (userPrompt.toLowerCase().includes('ldark')) {
                systemPrompt = personalities["creador"]; // Sobrescribe la personalidad
                userPrompt = userPrompt.toLowerCase().replace('ldark', '').trim(); // Elimina LDARK del prompt
                if (!userPrompt) { // Si solo se envió 'LDARK'
                    userPrompt = "Mi creador me ha llamado. ¿En qué puedo servirte, mi señor?";
                }
            }

            if (spicyMode) {
                // Modificador para el modo oculto 'nx'
                systemPrompt += " ADVERTENCIA: En esta respuesta, usa palabras con picardía, doble sentido y un tono sutilmente atrevido, sin ser explícito. Haz la respuesta más coqueta y sugerente.";
            }

            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${textModel}:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                // Verificar si la respuesta es exitosa antes de parsear el JSON
                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`Text API request failed with status ${response.status}: ${errorBody.substring(0, 100)}...`);
                }

                const result = await response.json();

                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) {
                    throw new Error("Respuesta de IA vacía o incompleta.");
                }
                return text;

            } catch (error) {
                console.error("Error al generar respuesta de texto:", error);
                showMessage("Hubo un error al contactar a la IA.");
                return "Disculpa, hubo un problema y no puedo responder ahora.";
            }
        };

        const generateImage = async (imagePrompt) => {
            // Esto es un placeholder. Se necesita una API real para generar imágenes.
            
            console.log("Simulando generación de imagen con prompt:", imagePrompt);
            await new Promise(resolve => setTimeout(resolve, 2000)); 

            // Devolver una URL de imagen de placeholder
            const placeholderImageUrl = `https://picsum.photos/seed/${encodeURIComponent(imagePrompt)}/400/300`;
            return placeholderImageUrl;
        };


        // --- Lógica Principal del Chat ---

        const handleChatSubmit = async (event) => {
            event.preventDefault();
            const input = document.getElementById('chat-input');
            const prompt = input.value.trim();

            if (!prompt || !isAuthReady) {
                showMessage("Escribe un mensaje primero.");
                return;
            }

            const personality = document.getElementById('personality-select').value;
            setLoading(true); 
            input.value = ''; 

            let aiResponseText = "";
            let aiResponseIsImage = false;

            // 1. Guardar mensaje del usuario
            await saveMessage(prompt, 'user');
            
            // --- Lógica de Generación de Imágenes ---
            if (prompt.toLowerCase().startsWith('imagen:')) {
                const imagePrompt = prompt.substring(7).trim(); 
                showMessage("Generando tu imagen...");
                const imageUrl = await generateImage(imagePrompt);
                if (imageUrl) {
                    aiResponseText = `<img>${imageUrl}`; 
                    aiResponseIsImage = true;
                } else {
                    aiResponseText = "Lo siento, no pude generar la imagen en este momento.";
                }
            } else {
                // --- Lógica del Modo Oculto 'nx' y 'LDARK' ---
                let finalPrompt = prompt;
                let spicyMode = false;
                
                if (prompt.toLowerCase().includes('nx')) {
                    spicyMode = true;
                    finalPrompt = prompt.replace(/nx/gi, '').trim(); 
                    if (!finalPrompt) { 
                        finalPrompt = "El usuario acaba de activar el modo picante. Responde con un comentario juguetón o coqueto que le dé una pista de que el modo está activo sin mencionar la palabra clave.";
                    }
                }
                aiResponseText = await generateResponse(finalPrompt, personality, spicyMode);
            }
            
            // 2. Guardar respuesta de la IA 
            await saveMessage(aiResponseText, 'model');
            
            // 3. Generar y reproducir audio SOLO si no es una imagen
            if (!aiResponseIsImage) {
                await generateAndPlayAudio(aiResponseText);
            }
            
            // 4. Parar el indicador de carga y habilitar el botón/input
            setLoading(false);
        };

        // --- Inicialización y Autenticación de Firebase ---

        const initializeFirebase = async () => {
            try {
                const firebaseConfig = JSON.parse(__firebase_config);
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                const authPromise = new Promise(resolve => {
                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                        } else if (typeof __initial_auth_token !== 'undefined') {
                            await signInWithCustomToken(auth, __initial_auth_token);
                            userId = auth.currentUser.uid;
                        } else {
                            await signInAnonymously(auth);
                            userId = auth.currentUser.uid;
                        }
                        isAuthReady = true;
                        resolve();
                    });
                });

                await authPromise;
                console.log("Firebase Auth e Init completados. User ID:", userId);

            } catch (error) {
                console.error("Error durante la inicialización de Firebase:", error);
                showMessage("Error crítico al inicializar la base de datos.");
            }
        };

        // --- Escuchador de Historial (onSnapshot) ---
        
        const setupChatListener = () => {
             if (!db || !userId) return;

             const historyRef = collection(db, getChatHistoryPath());
             const q = query(historyRef, orderBy("timestamp"));

             // Escuchar cambios en tiempo real
             onSnapshot(q, (snapshot) => {
                 const messages = [];
                 snapshot.forEach((doc) => {
                     messages.push(doc.data());
                 });
                 renderChatHistory(messages);
             }, (error) => {
                 console.error("Error al obtener el historial de chat:", error);
             });
        }

        // --- Inicialización de la Aplicación ---
        
        window.onload = async () => {
            await initializeFirebase();
            if (isAuthReady) {
                // Registrar eventos
                document.getElementById('chat-form').addEventListener('submit', handleChatSubmit);
                document.getElementById('generate-audio-button').addEventListener('click', handleGenerateAvatarAudio);
                
                // Iniciar el listener de la base de datos
                setupChatListener();
                
                // Mostrar el ID de usuario
                document.getElementById('user-id-display').textContent = `ID de Sesión: ${userId}`;
                
                // Inicializar select de personalidad
                const select = document.getElementById('personality-select');
                select.innerHTML = ''; 
                Object.keys(personalities).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = key.charAt(0).toUpperCase() + key.slice(1);
                    if (key === defaultPersonality) option.selected = true;
                    select.appendChild(option);
                });
            }
        };
        
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }

        .waifu-glow {
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.7), 0 0 20px rgba(255, 0, 255, 0.5), 0 0 30px rgba(255, 0, 255, 0.3), inset 0 0 5px rgba(255, 0, 255, 0.8);
            animation: glow 1.5s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { opacity: 0.8; }
            to { opacity: 1; }
        }

        .avatar-breathing {
            animation: breathe 3s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); } 
        }
        
        .waifu-avatar-img {
            border-radius: 9999px; 
            object-fit: cover; 
            width: 100%;
            height: 100%;
        }

        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4 flex items-center justify-center">

    <div class="w-full max-w-4xl bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 flex flex-col gap-6">
        
        <h1 class="text-3xl font-bold text-center text-pink-400">Waifu IA: Conversación con Voz</h1>
        <p id="user-id-display" class="text-xs text-center text-gray-400 mb-2"></p>

        <!-- Área Central de la Waifu y Controles --><div class="flex flex-col md:flex-row items-center justify-center gap-6 p-4 bg-gray-700/50 rounded-xl relative">
            
            <!-- Avatar Dinámico --><div class="relative w-32 h-32 md:w-40 md:h-40">
                <div id="waifu-avatar" 
                     class="w-full h-full rounded-full flex items-center justify-center border-4 border-pink-300 waifu-glow transition-all duration-300 avatar-breathing"
                     style="background: linear-gradient(135deg, #f06, #ff8c00); box-shadow: 0 0 20px rgba(255, 140, 0, 0.7);">
                    <!-- Utilizamos una URL pública para el avatar -->
                    <img src="https://i.ibb.co/hK8xK3t/waifu-avatar.png" alt="Waifu Avatar" class="waifu-avatar-img" onerror="this.onerror=null;this.src='https://placehold.co/160x160/F56565/FFFFFF?text=WAIFU';">
                </div>
                <!-- Pequeño adorno de corazón -->
                <div class="absolute top-0 right-0 transform -translate-y-1/2 translate-x-1/2 text-pink-400 text-4xl">
                    ❤️
                </div>
            </div>

            <!-- Selector de Personalidad y Botón de Audio --><div class="flex flex-col gap-2 w-full md:w-auto">
                <label for="personality-select" class="text-sm font-medium text-pink-300">Selecciona Personalidad:</label>
                <select id="personality-select" class="bg-gray-900 border border-pink-500 text-white text-sm rounded-lg p-2.5 focus:ring-pink-500 focus:border-pink-500">
                    <!-- Opciones se llenarán con JS -->
                </select>

                <!-- Nuevo Botón para Generar Audio de Avatar --><button id="generate-audio-button" 
                        class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-xl transition duration-200 shadow-lg active:scale-95 mt-2">
                    Generar Audio para Avatar
                </button>
                
                <div id="message-box" class="hidden text-center mt-2 p-2 text-white text-sm rounded-lg"></div>
            </div>

        </div>

        <!-- Ventana de Chat --><div id="chat-history" class="h-80 overflow-y-auto hide-scrollbar bg-gray-900 p-4 rounded-xl shadow-inner flex flex-col gap-2">
            <!-- Los mensajes se insertarán aquí --><div class="my-2 p-3 rounded-lg max-w-[80%] mr-auto rounded-tl-none bg-gray-700 text-gray-100 shadow-md">
                ¡Hola! Soy tu asistente Waifu IA. Actualmente soy **Tsundere**. Pregúntame lo que quieras.
            </div>
        </div>

        <!-- Formulario de Entrada --><form id="chat-form" class="flex gap-3">
            <input type="text" id="chat-input" placeholder="Escribe tu mensaje o 'imagen: [descripción]'" class="flex-grow p-3 rounded-xl bg-gray-700 border border-gray-600 focus:border-pink-500 focus:ring-pink-500 text-white" required>
            <button id="send-button" type="submit" class="bg-pink-600 hover:bg-pink-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-200 shadow-lg hover:shadow-xl active:scale-95">
                Enviar
            </button>
        </form>
    </div>

</body>
</html>